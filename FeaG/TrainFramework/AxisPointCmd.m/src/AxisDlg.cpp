// COPYRIGHT Dassault Systemes 2025
//===================================================================
//
// AxisDlg.cpp
// The dialog : AxisDlg
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2025  Creation: Code generated by the CAA wizard  user
//===================================================================
#include "AxisDlg.h"
#include "CATApplicationFrame.h"
#include "CATDlgGridConstraints.h"
#include "CATMsgCatalog.h"

//基础
#include "CATIProduct.h"
#include "CATISpecObject.h"
#include "CATILinkableObject.h"
#include "CATFrmEditor.h"
#include "CATDocumentServices.h"
#include "CATDocument.h"
#include "CATIDocRoots.h"
//检索
#include "CATIParmPublisher.h"
#include "CATIDescendants.h"
#include "CATIAlias.h"
//位姿
#include "CATIMovable.h"
#include "CATMathTransformation.h"
//几何
#include "CATCircle.h"
#include "CATConic.h"
#include "CATMathPoint.h"
#include "CATMathPlane.h"
#include "CATMathVector.h"
#include "CATMathDirection.h"
#include "CATPlane.h"
#include "CATLine.h"
#include "CATPoint.h"
#include "CATInit.h"
#include "CATIContainerOfDocument.h"
#include "CATIGSMFactory.h"
#include "CATIGSMPoint.h"
#include "CATIGSMProceduralView.h"
#include "CATIContainer.h"
#include "CATIModelEvents.h"
#include "CATIRedrawEvent.h"
#include "CATIInstance.h"
#include "CATModify.h"
//零件
#include "CATIPrtContainer.h"
#include "CATIPrtFactory.h"
#include "CATIPrtPart.h"


#include <iomanip>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include <algorithm>


#ifdef AxisDlg_ParameterEditorInclude
#include "CATIParameterEditorFactory.h"
#include "CATIParameterEditor.h"
#include "CATICkeParm.h"
#endif


// 三维向量结构体
struct Vec3 {
	double x, y, z;

	Vec3() : x(0), y(0), z(0) {}
	Vec3(double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}

	// 向量加法
	Vec3 operator+(const Vec3& v) const {
		return Vec3(x + v.x, y + v.y, z + v.z);
	}

	// 向量减法
	Vec3 operator-(const Vec3& v) const {
		return Vec3(x - v.x, y - v.y, z - v.z);
	}

	// 标量乘法
	Vec3 operator*(double s) const {
		return Vec3(x * s, y * s, z * s);
	}

	// 叉乘
	Vec3 cross(const Vec3& v) const {
		return Vec3(
			y * v.z - z * v.y,
			z * v.x - x * v.z,
			x * v.y - y * v.x
			);
	}

	// 点积
	double dot(const Vec3& v) const {
		return x * v.x + y * v.y + z * v.z;
	}

	// 模长
	double norm() const {
		return std::sqrt(x*x + y*y + z*z);
	}

	// 单位化
	Vec3 normalized() const {
		double len = norm();
		if (len < 1e-8) return Vec3(0, 0, 0);
		return Vec3(x / len, y / len, z / len);
	}
};

//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
AxisDlg::AxisDlg() :
  CATDlgDialog ((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),
//CAA2 WIZARD CONSTRUCTOR DECLARATION SECTION
"AxisDlg",CATDlgWndNoButton|CATDlgGridLayout
//END CAA2 WIZARD CONSTRUCTOR DECLARATION SECTION
                               )
{
//CAA2 WIZARD CONSTRUCTOR INITIALIZATION SECTION
 _PushButton001 = NULL;
 _PushButton002 = NULL;
 _Editor003 = NULL;
 _Label004 = NULL;
 _PushButton005 = NULL;
 _PushButton006 = NULL;
//END CAA2 WIZARD CONSTRUCTOR INITIALIZATION SECTION
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
AxisDlg::~AxisDlg()
{
//  Do not delete the control elements of your dialog: 
//     this is done automatically
//  --------------------------------------------------
//CAA2 WIZARD DESTRUCTOR DECLARATION SECTION
 _PushButton001 = NULL;
 _PushButton002 = NULL;
 _Editor003 = NULL;
 _Label004 = NULL;
 _PushButton005 = NULL;
 _PushButton006 = NULL;
//END CAA2 WIZARD DESTRUCTOR DECLARATION SECTION
}



void AxisDlg::Build()
{
//  TODO: This call builds your dialog from the layout declaration file
//  -------------------------------------------------------------------

//CAA2 WIZARD WIDGET CONSTRUCTION SECTION
 _PushButton001 = new CATDlgPushButton(this, "PushButton001");
_PushButton001 -> SetGridConstraints(0, 0, 1, 1, CATGRID_4SIDES);
 _PushButton002 = new CATDlgPushButton(this, "PushButton002");
_PushButton002 -> SetGridConstraints(0, 1, 1, 1, CATGRID_4SIDES);
 _Editor003 = new CATDlgEditor(this, "Editor003");
_Editor003 -> SetGridConstraints(1, 1, 1, 1, CATGRID_4SIDES);
 _Label004 = new CATDlgLabel(this, "Label004");
_Label004 -> SetGridConstraints(1, 0, 1, 1, CATGRID_4SIDES);
 _PushButton005 = new CATDlgPushButton(this, "PushButton005");
_PushButton005 -> SetGridConstraints(2, 0, 2, 1, CATGRID_4SIDES);
 _PushButton006 = new CATDlgPushButton(this, "PushButton006");
_PushButton006 -> SetGridConstraints(3, 0, 2, 1, CATGRID_4SIDES);
//END CAA2 WIZARD WIDGET CONSTRUCTION SECTION
_Editor003->SetText("E:\\PointData\\AxisData\\Axis.txt");
//CAA2 WIZARD CALLBACK DECLARATION SECTION
     AddAnalyseNotificationCB (_PushButton006, 
                               _PushButton006->GetPushBActivateNotification(),
                               (CATCommandMethod)&AxisDlg::OnPushButton006PushBActivateNotification,
                               NULL);
     AddAnalyseNotificationCB (this, 
                               GetWindCloseNotification(),
                               (CATCommandMethod)&AxisDlg::OnAxisDlgWindCloseNotification,
                               NULL);
//END CAA2 WIZARD CALLBACK DECLARATION SECTION

}

//返回按键指针
CATDlgPushButton*  AxisDlg::GetFiled(int chosenbutton){
	switch (chosenbutton)
	{
	case 1 : return _PushButton001;
	case 2: return _PushButton002;
	case 3: return _PushButton005;
	default:
		break;
	}
	return NULL;
}

void AxisDlg::GetCircleParameter(CATBaseUnknown *pcir, CATPathElement* pcirpath, std::vector<double>& cirparameters){
	////获得所属产品节点
	//CATBaseUnknown* pProductBu = pcirpath->FindElement(IID_CATIProduct);
	//CATIProduct* pTarProduct = NULL;
	//HRESULT rc = pProductBu->QueryInterface(IID_CATIProduct, (void **)&pTarProduct);

	////获取根节点
	//rc=E_FAIL;
	//CATBaseUnknown * pRootProduct = NULL;
	//CATIProduct *piRootProduct = NULL;
	//CATFrmEditor * pEditor = CATFrmEditor::GetCurrentEditor();
	//CATDocument * pDoc = pEditor -> GetDocument();
	//CATIDocRoots * piDocRootsDoc = NULL;
	//rc = pDoc -> QueryInterface(IID_CATIDocRoots,(void **)&piDocRootsDoc);
	//CATIProduct_var spRootProduct = NULL_var;
	//if(SUCCEEDED(rc)){
	//	CATListValCATBaseUnknown_var * pRootProducts = piDocRootsDoc -> GiveDocRoots();
	//	if(NULL != pRootProducts){
	//		if(pRootProducts -> Size()>0){
	//			spRootProduct = (*pRootProducts)[1];
	//		}
	//		delete pRootProducts;
	//		pRootProducts = NULL;
	//	}
	//	piDocRootsDoc -> Release();
	//	piDocRootsDoc = NULL;
	//}

	//if (SUCCEEDED(rc))
	//{
	//	rc = spRootProduct->QueryInterface(IID_CATIProduct, (void**) &piRootProduct);

	//	//获得产品实例
	//	CATIProduct_var spPosProduct;
	//	CATIProduct_var spReferenceProduct = piRootProduct -> GetReferenceProduct();
	//	spPosProduct = pTarProduct->FindInstance(spReferenceProduct);
	//	CATIMovable* piCurPartMovable;
	//	rc = spPosProduct->QueryInterface(IID_CATIMovable,(void**)&piCurPartMovable);

	//	//获得装配体下选中零件位姿
	//	double PipePartArray[16];
	//	CATMathTransformation PipePartPosition;
	//	piCurPartMovable->GetAbsPosition(PipePartPosition);
	//	PipePartPosition.GetCoef(PipePartArray,16);

	//	//逆矩阵
	//	double PipePartArrayInv[16] = {0};
	//	for (int i = 0; i < 4; i++)
	//	{
	//		for (int j = 0; j < 4; j++)
	//		{
	//			PipePartArrayInv[4*i + j] = PipePartArray[4*j + i];
	//		}
	//	}

	//	//获得曲线
	//	CATCircle* pBdCircle;
	//	CATConic* pConic ;
	//	rc = pcir->QueryInterface(IID_CATCircle, (void **)&pBdCircle);
	//	if(SUCCEEDED(rc)&&pBdCircle!=NULL)
	//	{
	//		pConic = pBdCircle;
	//	}

	//	//获得参数
	//	double radius;
	//	radius = pBdCircle -> GetRadius();
	//	CATMathPoint Centerpoint;
	//	pConic -> GetOrigin(Centerpoint);
	//	CATMathPlane SupportPlane;
	//	pConic->GetSupport(SupportPlane);
	//	CATMathVector NormalVector;
	//	SupportPlane.GetNormal(NormalVector);
	//	NormalVector.Normalize();

	//	double cx,cy,cz,nx,ny,nz;
	//	cx = Centerpoint.GetX();cy = Centerpoint.GetY();cz = Centerpoint.GetZ();
	//	nx = NormalVector.GetX();ny = NormalVector.GetY();nz = NormalVector.GetZ();

	//	double ncx,ncy,ncz,nnx,nny,nnz;
	//	ncx = PipePartArrayInv[0] * cx + PipePartArrayInv[1] * cy + PipePartArrayInv[2] * cz + PipePartArrayInv[3];
	//	ncy = PipePartArrayInv[4] * cx + PipePartArrayInv[5] * cy + PipePartArrayInv[6] * cz + PipePartArrayInv[7];
	//	ncz = PipePartArrayInv[8] * cx + PipePartArrayInv[9] * cy + PipePartArrayInv[10] * cz + PipePartArrayInv[11];
	//	nnx = PipePartArrayInv[0] * nx + PipePartArrayInv[1] * ny + PipePartArrayInv[2] * nz;
	//	nny = PipePartArrayInv[4] * nx + PipePartArrayInv[5] * ny + PipePartArrayInv[6] * nz;
	//	nnz = PipePartArrayInv[8] * nx + PipePartArrayInv[9] * ny + PipePartArrayInv[10] * nz;

	//	cirparameters.clear();
	//	cirparameters.push_back(ncx); cirparameters.push_back(ncy); cirparameters.push_back(ncz); cirparameters.push_back(nnx); cirparameters.push_back(nny); cirparameters.push_back(nnz); 
	//}

	HRESULT rc = E_FAIL;
	CATCircle* pBdCircle;
	CATConic* pConic ;
	rc = pcir->QueryInterface(IID_CATCircle, (void **)&pBdCircle);
	if(SUCCEEDED(rc)&&pBdCircle!=NULL)
	{
		pConic = pBdCircle;
		CATMathPoint Centerpoint;
		pConic -> GetOrigin(Centerpoint);
		CATMathPlane SupportPlane;
		pConic->GetSupport(SupportPlane);
		CATMathVector NormalVector;
		SupportPlane.GetNormal(NormalVector);
		NormalVector.Normalize();

		double cx,cy,cz,nx,ny,nz;
		cx = Centerpoint.GetX();cy = Centerpoint.GetY();cz = Centerpoint.GetZ();
		nx = NormalVector.GetX();ny = NormalVector.GetY();nz = NormalVector.GetZ();

		cirparameters.clear();
		cirparameters.push_back(cx); cirparameters.push_back(cy); cirparameters.push_back(cz); cirparameters.push_back(nx); cirparameters.push_back(ny); cirparameters.push_back(nz); 

		//输出
		const char* Cfilepath = "E:\\PointData\\CircleData\\Circles.txt";
		std::ofstream out(Cfilepath, ios::app);
		if (!out.is_open()) {
			return;
		}

		for (int ci = 0; ci < 6; ci++) {
			out << std::fixed << std::setprecision(6)
				<< cirparameters[ci] << ",";
		}
		out << "\n";
		out.close();
	}

	//获得参数
	//double radius;
	//radius = pBdCircle -> GetRadius();

}

void AxisDlg::GetPntParameter(CATBaseUnknown *ppnt, CATPathElement* ppntpath, std::vector<double>& pntparameters){
	////获得所属产品节点
	//CATBaseUnknown* pProductBu = ppntpath->FindElement(IID_CATIProduct);
	//CATIProduct* pTarProduct = NULL;
	//HRESULT rc = pProductBu->QueryInterface(IID_CATIProduct, (void **)&pTarProduct);

	////获取根节点
	//rc=E_FAIL;
	//CATBaseUnknown * pRootProduct = NULL;
	//CATIProduct *piRootProduct = NULL;
	//CATFrmEditor * pEditor = CATFrmEditor::GetCurrentEditor();
	//CATDocument * pDoc = pEditor -> GetDocument();
	//CATIDocRoots * piDocRootsDoc = NULL;
	//rc = pDoc -> QueryInterface(IID_CATIDocRoots,(void **)&piDocRootsDoc);
	//CATIProduct_var spRootProduct = NULL_var;
	//if(SUCCEEDED(rc)){
	//	CATListValCATBaseUnknown_var * pRootProducts = piDocRootsDoc -> GiveDocRoots();
	//	if(NULL != pRootProducts){
	//		if(pRootProducts -> Size()>0){
	//			spRootProduct = (*pRootProducts)[1];
	//		}
	//		delete pRootProducts;
	//		pRootProducts = NULL;
	//	}
	//	piDocRootsDoc -> Release();
	//	piDocRootsDoc = NULL;
	//}

	//if (SUCCEEDED(rc))
	//{
	//	rc = spRootProduct->QueryInterface(IID_CATIProduct, (void**) &piRootProduct);

	//	//获得产品实例
	//	CATIProduct_var spPosProduct;
	//	CATIProduct_var spReferenceProduct = piRootProduct -> GetReferenceProduct();
	//	spPosProduct = pTarProduct->FindInstance(spReferenceProduct);
	//	CATIMovable* piCurPartMovable;
	//	rc = spPosProduct->QueryInterface(IID_CATIMovable,(void**)&piCurPartMovable);

	//	//获得装配体下选中零件位姿
	//	double PipePartArray[16];
	//	CATMathTransformation PipePartPosition;
	//	piCurPartMovable->GetAbsPosition(PipePartPosition);
	//	PipePartPosition.GetCoef(PipePartArray,16);

	//	//逆矩阵
	//	double PipePartArrayInv[16] = {0};
	//	for (int i = 0; i < 4; i++)
	//	{
	//		for (int j = 0; j < 4; j++)
	//		{
	//			PipePartArrayInv[4*i + j] = PipePartArray[4*j + i];
	//		}
	//	}

	//	//获得曲线
	//	CATPoint* pPoint;
	//	rc = ppnt->QueryInterface(IID_CATCircle, (void **)&pPoint);
	//	double cx,cy,cz;
	//	if(SUCCEEDED(rc)&&pPoint!=NULL)
	//	{
	//		pPoint->GetCoord(cx,cy,cz);
	//	}

	//	double ncx,ncy,ncz;
	//	ncx = PipePartArrayInv[0] * cx + PipePartArrayInv[1] * cy + PipePartArrayInv[2] * cz + PipePartArrayInv[3];
	//	ncy = PipePartArrayInv[4] * cx + PipePartArrayInv[5] * cy + PipePartArrayInv[6] * cz + PipePartArrayInv[7];
	//	ncz = PipePartArrayInv[8] * cx + PipePartArrayInv[9] * cy + PipePartArrayInv[10] * cz + PipePartArrayInv[11];

	//	pntparameters.clear();
	//	pntparameters.push_back(ncx); pntparameters.push_back(ncy); pntparameters.push_back(ncz);  
	HRESULT rc = E_FAIL;
	CATPoint* pPoint;
	rc = ppnt->QueryInterface(IID_CATPoint, (void **)&pPoint);
	double cx,cy,cz;
	if(SUCCEEDED(rc)&&pPoint!=NULL)
	{
		pPoint->GetCoord(cx,cy,cz);
	}
	//double ncx,ncy,ncz;
	//ncx = PipePartArrayInv[0] * cx + PipePartArrayInv[1] * cy + PipePartArrayInv[2] * cz + PipePartArrayInv[3];
	//ncy = PipePartArrayInv[4] * cx + PipePartArrayInv[5] * cy + PipePartArrayInv[6] * cz + PipePartArrayInv[7];
	//ncz = PipePartArrayInv[8] * cx + PipePartArrayInv[9] * cy + PipePartArrayInv[10] * cz + PipePartArrayInv[11];

	pntparameters.clear();
	pntparameters.push_back(cx); pntparameters.push_back(cy); pntparameters.push_back(cz);  
}
//-------------------------------------------------------------------------
// Callback on WindClose of _AxisDlg
//-------------------------------------------------------------------------
void AxisDlg::OnAxisDlgWindCloseNotification(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	this -> SetVisibility(CATDlgHide);
	this -> RequestDelayedDestruction();
}

//直线
void AxisDlg::CalLine(const std::vector<double> p1, const std::vector<double> p2, const char* filepath){
	// 检查输入是否合法
	if (p1.size() != 3 || p2.size() != 3) {
		return;
	}

	// 计算两点间距离
	double dx = p2[0] - p1[0];
	double dy = p2[1] - p1[1];
	double dz = p2[2] - p1[2];
	double distance = std::sqrt(dx * dx + dy * dy + dz * dz);

	if (distance <= 1e-6) {
		return;
	}

	// 单位向量方向
	double unit_x = dx / distance;
	double unit_y = dy / distance;
	double unit_z = dz / distance;

	// 总共要插补的点数（包含起点和终点）
	//直线点间距linedis
	double linedis = 5;
	int num_points = static_cast<int>(distance / linedis) + 1;

	// 打开文件用于写入
	std::ofstream outFile(filepath, ios::app);
	if (!outFile.is_open()) {
		return;
	}

	// 插补并写入文件
	for (int i = 0; i < num_points; ++i) {
		double t = i * (distance/num_points); 
		double x = p1[0] + unit_x * t;
		double y = p1[1] + unit_y * t;
		double z = p1[2] + unit_z * t;

		outFile << std::fixed << std::setprecision(6)
			<< x << ","
			<< y << ","
			<< z << std::endl;
	}
	outFile.close();
}

// 解二元一次方程组 Ax + By = C
bool solveLinearSystem2x2(double A11, double A12, double b1,
						  double A21, double A22, double b2,
						  double& x, double& y) {
							  double det = A11 * A22 - A12 * A21;
							  if (std::abs(det) < 1e-8) return false; // 无唯一解

							  x = (b1 * A22 - b2 * A12) / det;
							  y = (b2 * A11 - b1 * A21) / det;
							  return true;
}

std::vector<double> lineIntersection(double x1, double y1, double z1, 
									 double x2, double y2, double z2, 
									 double vx1, double vy1, double vz1, 
									 double vx2, double vy2, double vz2) {
	 std::vector<double> nonvec;
	 nonvec.clear();
	 // 构建系数矩阵
	 double a = vx1, b = -vx2, c = x2 - x1;
	 double d = vy1, e = -vy2, f = y2 - y1;
	 double g = vz1, h = -vz2, i = z2 - z1;

	 // 计算行列式
	 double det1 = a * e - d * b;
	 double det2 = a * h - g * b;
	 double det3 = d * h - g * e;

	 // 如果行列式都为0，则两直线平行或共线
	 if (std::abs(det1) < 1e-10 && std::abs(det2) < 1e-10 && std::abs(det3) < 1e-10) {
		 // 检查两直线是否共线
		 double t_check;
		 bool colinear = true;

		 // 检查x分量
		 if (std::abs(vx1) > 1e-10) {
			 t_check = (x2 - x1) / vx1;
			 if (std::abs(y2 - y1 - t_check * vy1) > 1e-10 || 
				 std::abs(z2 - z1 - t_check * vz1) > 1e-10) {
					 colinear = false;
			 }
		 } 
		 // 检查y分量
		 else if (std::abs(vy1) > 1e-10) {
			 t_check = (y2 - y1) / vy1;
			 if (std::abs(x2 - x1 - t_check * vx1) > 1e-10 || 
				 std::abs(z2 - z1 - t_check * vz1) > 1e-10) {
					 colinear = false;
			 }
		 } 
		 // 检查z分量
		 else if (std::abs(vz1) > 1e-10) {
			 t_check = (z2 - z1) / vz1;
			 if (std::abs(x2 - x1 - t_check * vx1) > 1e-10 || 
				 std::abs(y2 - y1 - t_check * vy1) > 1e-10) {
					 colinear = false;
			 }
		 }

		 if (colinear) {
			 // 共线时返回第一个点
			 return nonvec;
		 } else {
			 // 平行但不共线，返回空向量
			 return nonvec;
		 }
	 }

	 // 解方程组求参数t和s
	 double t, s;
	 if (std::abs(det1) > 1e-10) {
		 t = (e * c - b * f) / det1;
		 s = (a * f - d * c) / det1;
	 } else if (std::abs(det2) > 1e-10) {
		 t = (h * c - b * i) / det2;
		 s = (a * i - g * c) / det2;
	 } else if (std::abs(det3) > 1e-10) {
		 t = (h * f - e * i) / det3;
		 s = (d * i - g * f) / det3;
	 } else {
		 // 无法解方程组，返回空向量
		 return nonvec;
	 }

	 // 计算交点坐标
	 double x = x1 + t * vx1;
	 double y = y1 + t * vy1;
	 double z = z1 + t * vz1;

	 // 验证另一条直线上的点是否相同
	 double x_other = x2 + s * vx2;
	 double y_other = y2 + s * vy2;
	 double z_other = z2 + s * vz2;

	 // 如果两个点足够接近，则认为是交点
	 if (std::abs(x - x_other) < 0.1 && 
		 std::abs(y - y_other) < 0.1 && 
		 std::abs(z - z_other) < 0.1) {
			 std::vector<double> resvec;
			 resvec.clear(); resvec.push_back(x); resvec.push_back(y); resvec.push_back(z);
			 return resvec;
	 } else {
		 // 两直线异面，返回空向量
		 return nonvec;
	 }
}  

void AxisDlg::CalCircle(const std::vector<double> p1, const std::vector<double> p2, const char* filepath){
	if (p1.size() != 6 || p2.size() != 6) {
		return;
	}

	// 提取点和法向量
	Vec3 A(p1[0], p1[1], p1[2]);
	Vec3 tA(p1[3], p1[4], p1[5]);

	Vec3 B(p2[0], p2[1], p2[2]);
	Vec3 tB(p2[3], p2[4], p2[5]);

	// 单位化切向量
	tA = tA.normalized();
	tB = tB.normalized();

	// 平面法向量
	Vec3 normal = tA.cross(tB);
	if (normal.norm() < 1e-6) {
		return;//共线
	}
	normal = normal.normalized();

	// 构造垂线方向
	Vec3 dir1 = normal.cross(tA).normalized();
	Vec3 dir2 = normal.cross(tB).normalized();

	std::vector<double> CenterCor = lineIntersection(A.x,A.y,A.z,B.x,B.y,B.z,dir1.x,dir1.y,dir1.z,dir2.x,dir2.y,dir2.z);

	if (CenterCor.size() == 0)
	{
		std::cerr<<"无法计算圆心"<<std::endl;
	}
	// 圆心 C
	Vec3 C(CenterCor[0],CenterCor[1],CenterCor[2]);

	// 半径
	double radius = (A - C).norm();

	// 局部坐标系
	Vec3 e1 = (A - C).normalized(); // x轴方向(起始方向）
	Vec3 e2 = normal.cross(e1);     // y轴方向

	//调试信息输出
	const char* midinf = "E:\\MidTest.txt";
	std::ofstream mid(midinf);
	if (!mid.is_open()) {
		return;
	}
	mid<< dir1.x << ","<< dir1.y << ","<< dir1.z << "\n";
	mid<< dir2.x << ","<< dir2.y << ","<< dir2.z << "\n";
	mid<< C.x << ","<< C.y << ","<< C.z << "\n";
	mid.close();

	// 计算局部坐标系下的两个单位向量
	Vec3 e3 = (B - C).normalized(); // 终止方向

	Vec3 cross_dir = e1.cross(e3);
	double cos_theta = e1.dot(e3);

	double angle;
	if (cos_theta<1 && cos_theta>-1)
	{
		angle = acos(cos_theta);
	}
	else{
		return;
	}

	if (cross_dir.dot(normal) < 0) {
		angle = -angle;
	}

	// 点数与半径成比例(弧长比距离）
	double circledis = 5;
	int n_points = static_cast<int>(radius * abs(angle) / circledis);

	// 采样圆弧点
	std::vector<Vec3> arc_points;
	for (int i = 0; i <= n_points; ++i) {
		double theta = i * angle / n_points;
		double ct = std::cos(theta);
		double st = std::sin(theta);
		Vec3 pt = C + e1 * (ct * radius) + e2 * (st * radius);
		arc_points.push_back(pt);
	}

	//输出
	std::ofstream out(filepath, ios::app);
	if (!out.is_open()) {
		return;
	}

	for (int vi = 0; vi < arc_points.size(); vi++) {
		Vec3 pt = arc_points[vi];
		out << std::fixed << std::setprecision(6)
			<< pt.x << ","
			<< pt.y << ","
			<< pt.z << "\n";
	}

	out.close();
}


//-------------------------------------------------------------------------
// Callback on PushBActivate of _PushButton006
//随机生成管路模型
//根据文件生成关键点
//-------------------------------------------------------------------------
void AxisDlg::OnPushButton006PushBActivateNotification(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	//读取文件
	std::vector<std::vector<double>> Keypoints;
	CATUnicodeString filename = _Editor003->GetText();
	const char *filepath=filename.ConvertToChar();
	std::ifstream file(filepath);
	if (!file.is_open()) {
		std::cerr << "无法打开轴线文件: " << filename << std::endl;
		return;
	}

	std::string line;
	while (std::getline(file, line)) {
		if (line.empty()) continue;

		std::istringstream iss(line);
		std::string type;
		iss >> type;

		if (type == "LINE") {
			double x1, y1, z1, x2, y2, z2;
			if (iss >> x1 >> y1 >> z1 >> x2 >> y2 >> z2) {
				std::vector<double>Point;
				Point.push_back(x1); Point.push_back(y1); Point.push_back(z1);
				Keypoints.push_back(Point);
				Point[0] = x2; Point[1] = y2; Point[2] = z2;
				Keypoints.push_back(Point);
			}
		}
		else if (type == "ARC") {
			double x1, y1, z1, x2, y2, z2, cx, cy, cz, r, x3, y3,z3;
			if (iss >> x1 >> y1 >> z1 >> x2 >> y2 >> z2 >> cx >> cy >> cz >> r >> x3 >> y3 >> z3) {
				std::vector<double>Point;
				Point.push_back(x1); Point.push_back(y1); Point.push_back(z1);
				Keypoints.push_back(Point);
				Point[0] = x2; Point[1] = y2; Point[2] = z2;
				Keypoints.push_back(Point);
				Point[0] = x3; Point[1] = y3; Point[2] = z3;
				Keypoints.push_back(Point);
			}
		}
	}
	//筛出重复点
	// 定义子向量类型别名，提高可读性
	typedef std::vector<double> DoubleVec;
	typedef std::vector<DoubleVec>::iterator VecIter;
	std::sort(Keypoints.begin(), Keypoints.end());
	VecIter it = std::unique(Keypoints.begin(), Keypoints.end());
	Keypoints.erase(it, Keypoints.end());

	//创建点
	//装配文档根节点
	CATFrmEditor* pEditor = CATFrmEditor::GetCurrentEditor();
	CATDocument* pDoc = pEditor -> GetDocument();
	CATIDocRoots* piDocRootsDoc = NULL;
	HRESULT rc = E_FAIL;
	rc = pDoc -> QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsDoc);
	CATIProduct_var spRoot = NULL_var;
	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsDoc -> GiveDocRoots();
	spRoot = (*pRootProducts)[1];
	delete pRootProducts;pRootProducts = NULL;
	piDocRootsDoc -> Release();
	piDocRootsDoc = NULL;

	//新建文档
	CATDocument* pPrtDoc = NULL;
	CATDocumentServices::New("Part",pPrtDoc);

	//获取container
	CATIContainerOfDocument_var spConODocs = pPrtDoc;
	CATIContainer* pSpecContainer = NULL;
	HRESULT hr = spConODocs -> GetSpecContainer(pSpecContainer);

	//获取CATIPrtpart变量
	CATInit_var spInit(pPrtDoc);
	CATIPrtContainer* spPrtCont = NULL;
	spPrtCont = (CATIPrtContainer*)spInit -> GetRootContainer("CATIPrtContainer");
	CATIPrtPart_var spPart = spPrtCont ->GetPart();

	CATIGSMFactory_var spGSMFactory;
	spGSMFactory = spPrtCont;
	//设置点的坐标
	for(int i = 0; i < Keypoints.size(); i++)
	{

		double CorX,CorY,CorZ;
		CorX = Keypoints[i][0];
		CorY = Keypoints[i][1];
		CorZ = Keypoints[i][2];
		CATMathPoint _Point;

		_Point.SetCoord(CorX,CorY,CorZ);
		//画点
		CATISpecObject_var		spSpecPoint;

		CATIGSMPoint_var spPoint = spGSMFactory->CreatePoint(_Point);
		spSpecPoint = spPoint;				
		CATIGSMProceduralView_var spSndPntObj = spSpecPoint;
		spSndPntObj->InsertInProceduralView();
	}

	CATIDocRoots* piDocRootsOnDoc = NULL;
	pPrtDoc ->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
	CATListValCATBaseUnknown_var* pProductList = piDocRootsOnDoc -> GiveDocRoots();
	CATBaseUnknown* pRootProduct = NULL;
	CATIProduct_var spPartRoot = NULL_var;
	pRootProduct = (*pProductList)[1];
	spPartRoot = pRootProduct;
	delete pProductList;
	pProductList = NULL;
	CATIProduct_var inst2Product = spRoot ->AddProduct(spPartRoot);

	CATIModelEvents_var spEvents = spRoot;
	CATModify ModifyEvent(spRoot);
	spEvents -> Dispatch(ModifyEvent);

	CATIRedrawEvent_var spRedraw = spRoot;
	spRedraw -> Redraw();
}
